<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Swedish Vocabulary Matching Game</title>
  <!-- Load Lexend font -->
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    body {
      font-family: 'Lexend', sans-serif;
      background-color: #f7f7ff; /* soft pastel background */
      margin: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      color: #333;
    }
    h1 {
      font-weight: 700;
      text-align: center;
      margin-bottom: 20px;
    }
    h2 {
      font-weight: 500;
      margin: 10px 0;
    }
    h3 {
      font-weight: 300;
      margin: 10px 0 5px;
    }
    .hidden {
      display: none;
    }
    
    /* Input Screen */
    #inputSection {
      text-align: center;
    }
    textarea {
      width: 100%;
      height: 200px;
      font-size: 16px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      margin-bottom: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #a3c4f3; /* pastel blue */
      color: white;
      cursor: pointer;
      margin: 5px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .time-selector {
      display: inline-flex;
      align-items: center;
      margin-bottom: 20px;
    }
    .time-selector button {
      font-size: 18px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 10px;
    }
    #timeDisplay {
      font-size: 20px;
      font-weight: 500;
    }
    
    /* Game Screen */
    #gameHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    #gameHeader button {
      padding: 5px 10px;
      font-size: 14px;
      border-radius: 4px;
    }
    #timerDisplay {
      font-size: 24px;
      font-weight: 500;
    }
    
    #gameBoard {
      display: flex;
      justify-content: space-between;
    }
    .column {
      width: 45%;
    }
    /* Fixed board slots */
    .slot {
      height: 50px;
      margin: 5px 0;
      position: relative;
      border: 1px dashed #ddd;
      border-radius: 8px;
      background-color: #fafafa;
    }
    .card {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: background-color 0.5s ease, opacity 0.5s ease;
      font-size: 16px;
      user-select: none;
      background-color: #fff;
      border: 1px solid #eee;
    }
    .card.selected {
      background-color: #fffacd; /* pastel yellow */
    }
    .card.correct {
      background-color: #c8e6c9; /* pastel green */
    }
    .card.wrong {
      background-color: #ffcdd2; /* pastel red */
    }
    
    /* Results Screen */
    #resultsSection {
      text-align: center;
    }
    #resultsTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    #resultsTable th, #resultsTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }
    #resultsTable th {
      background-color: #f0f0f0;
    }
    .correct-count {
      color: darkgreen;
      font-weight: bold;
    }
    .mismatch-count {
      color: darkred;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Swedish Vocabulary Matching Game</h1>
  
  <!-- Input Screen -->
  <div id="inputSection">
    <h2>Enter Your Vocabulary</h2>
    <p>
      Paste your vocabulary data below.<br>
      Use a tab or comma to separate the English and Swedish words (one pair per line).<br>
      <em>Example:</em> computer [tab] dator<br> dog [tab] hund<br> table [tab] bord
    </p>
    <textarea id="vocabInput" placeholder="computer [tab] dator&#10;dog [tab] hund&#10;table [tab] bord"></textarea>
    
    <!-- Time Selector -->
    <div class="time-selector">
      <button id="decreaseTime">←</button>
      <span id="timeDisplay">02:00</span>
      <button id="increaseTime">→</button>
    </div>
    <br>
    <button id="startButton" disabled>Start Game</button>
  </div>
  
  <!-- Game Screen -->
  <div id="gameSection" class="hidden">
    <div id="gameHeader">
      <button id="backButton">← Back</button>
      <div id="timerDisplay">00:00</div>
      <button id="finishButton">Finish</button>
    </div>
    <div id="gameBoard">
      <div id="englishColumn" class="column">
        <h3>English</h3>
        <!-- 6 fixed slots -->
      </div>
      <div id="swedishColumn" class="column">
        <h3>Swedish</h3>
        <!-- 6 fixed slots -->
      </div>
    </div>
  </div>
  
  <!-- Results Screen -->
  <div id="resultsSection" class="hidden">
    <h2>Results</h2>
    <p id="totalsDisplay"></p>
    <table id="resultsTable">
      <thead>
        <tr>
          <th>English</th>
          <th>Swedish</th>
          <th>Correct Matches</th>
          <th>Mismatches</th>
        </tr>
      </thead>
      <tbody id="resultsBody"></tbody>
    </table>
    <br>
    <button id="replayButton">Replay</button>
    <button id="newWordsButton">New Words</button>
  </div>
  
  <script>
    /***********************
     * Global Variables
     ***********************/
    let vocabularyPairs = [];     // All vocabulary pairs from input.
    let remainingPairs = [];      // Pairs not yet placed on board.
    let totalCorrectMatches = 0;  // Total number of correct matches.
    let totalMismatches = 0;      // Total number of mismatches.
    // Tracking counts for each pair id:
    let pairStats = {};           // { id: { correct: number, mismatches: number, english: "", swedish: "" } }
    
    // Board arrays (6 fixed slots per column)
    const totalSlots = 6;
    let englishBoard = new Array(totalSlots).fill(null);  // each element is a pair object or null.
    let swedishBoard = new Array(totalSlots).fill(null);
    
    // Currently selected card (object with properties: element, pairId, column, slot)
    let selectedCard = null;
    
    // Timer variables
    let timerInterval;
    let timeLeft = 120;   // in seconds (default 2 minutes)
    
    // For storing original vocabulary for replay.
    let originalVocabulary = [];
    
    /***********************
     * DOM Elements
     ***********************/
    const vocabInput = document.getElementById('vocabInput');
    const startButton = document.getElementById('startButton');
    const inputSection = document.getElementById('inputSection');
    const gameSection = document.getElementById('gameSection');
    const englishColumn = document.getElementById('englishColumn');
    const swedishColumn = document.getElementById('swedishColumn');
    const timerDisplay = document.getElementById('timerDisplay');
    const backButton = document.getElementById('backButton');
    const finishButton = document.getElementById('finishButton');
    const resultsSection = document.getElementById('resultsSection');
    const totalsDisplay = document.getElementById('totalsDisplay');
    const resultsBody = document.getElementById('resultsBody');
    const replayButton = document.getElementById('replayButton');
    const newWordsButton = document.getElementById('newWordsButton');
    const decreaseTimeBtn = document.getElementById('decreaseTime');
    const increaseTimeBtn = document.getElementById('increaseTime');
    const timeDisplay = document.getElementById('timeDisplay');
    
    /***********************
     * Input Screen Logic
     ***********************/
    // Enable start button if there is any text.
    vocabInput.addEventListener('input', () => {
      startButton.disabled = vocabInput.value.trim().length === 0;
    });
    
    // Timer selection logic
    let selectedTime = 120; // default in seconds (2 minutes)
    const MIN_TIME = 30;    // 30 seconds
    const MAX_TIME = 600;   // 10 minutes
    
    function updateTimeDisplay() {
      const m = Math.floor(selectedTime / 60);
      const s = selectedTime % 60;
      timeDisplay.textContent = (m < 10 ? '0' + m : m) + ':' + (s < 10 ? '0' + s : s);
    }
    updateTimeDisplay();
    
    decreaseTimeBtn.addEventListener('click', () => {
      // Decrease time in steps: 120 -> 60 -> 30 sec.
      if (selectedTime > MIN_TIME) {
        if (selectedTime === 120) {
          selectedTime = 60;
        } else if (selectedTime === 60) {
          selectedTime = 30;
        } else {
          // If above 120, decrease by 60.
          selectedTime = Math.max(selectedTime - 60, MIN_TIME);
        }
        updateTimeDisplay();
      }
    });
    increaseTimeBtn.addEventListener('click', () => {
      if (selectedTime < MAX_TIME) {
        // Increase by 60 seconds if below 120, otherwise by 60 seconds.
        selectedTime = Math.min(selectedTime + 60, MAX_TIME);
        updateTimeDisplay();
      }
    });
    
    // Start Game button event
    startButton.addEventListener('click', () => {
      parseVocabulary();
      if (vocabularyPairs.length === 0) {
        alert("No valid vocabulary pairs found. Please check your input.");
        return;
      }
      // Save a copy for replay.
      originalVocabulary = JSON.parse(JSON.stringify(vocabularyPairs));
      initializePairStats();
      resetGameState();
      // Set game timer from selectedTime.
      timeLeft = selectedTime;
      // Hide input, show game.
      inputSection.classList.add('hidden');
      resultsSection.classList.add('hidden');
      gameSection.classList.remove('hidden');
      renderFixedSlots();
      fillAllEmptySlots();
      startTimer();
    });
    
    // Parse vocabulary input (each line: English [tab/comma] Swedish)
    function parseVocabulary() {
      vocabularyPairs = [];
      const lines = vocabInput.value.trim().split('\n');
      let id = 0;
      lines.forEach(line => {
        const parts = line.split(/\t|,/);
        if (parts.length >= 2) {
          const english = parts[0].trim();
          const swedish = parts[1].trim();
          if (english && swedish) {
            const pair = { id: id, english: english, swedish: swedish };
            vocabularyPairs.push(pair);
            id++;
          }
        }
      });
      // Create a copy for game play.
      remainingPairs = vocabularyPairs.slice();
    }
    
    // Initialize pairStats for each vocabulary pair.
    function initializePairStats() {
      pairStats = {};
      vocabularyPairs.forEach(pair => {
        pairStats[pair.id] = { correct: 0, mismatches: 0, english: pair.english, swedish: pair.swedish };
      });
      totalCorrectMatches = 0;
      totalMismatches = 0;
    }
    
    // Reset boards and selected card.
    function resetGameState() {
      englishBoard = new Array(totalSlots).fill(null);
      swedishBoard = new Array(totalSlots).fill(null);
      selectedCard = null;
    }
    
    /***********************
     * Game Screen Logic
     ***********************/
    // Render fixed slots for each column.
    function renderFixedSlots() {
      englishColumn.innerHTML = '<h3>English</h3>';
      swedishColumn.innerHTML = '<h3>Swedish</h3>';
      for (let i = 0; i < totalSlots; i++) {
        const engSlot = document.createElement('div');
        engSlot.className = 'slot';
        engSlot.dataset.slot = i;
        englishColumn.appendChild(engSlot);
        
        const sweSlot = document.createElement('div');
        sweSlot.className = 'slot';
        sweSlot.dataset.slot = i;
        swedishColumn.appendChild(sweSlot);
      }
    }
    
    // Fill empty slots (without shuffling other cards)
    function fillAllEmptySlots() {
      for (let i = 0; i < totalSlots; i++) {
        if (!englishBoard[i] && remainingPairs.length > 0) {
          englishBoard[i] = remainingPairs.shift();
        }
        if (!swedishBoard[i] && remainingPairs.length > 0) {
          swedishBoard[i] = remainingPairs.shift();
        }
      }
      renderBoard();
    }
    
    // Render board: update each slot with its card.
    function renderBoard() {
      // For English column
      const engSlots = englishColumn.querySelectorAll('.slot');
      engSlots.forEach((slotEl, index) => {
        slotEl.innerHTML = ''; // clear slot content
        if (englishBoard[index]) {
          const card = createCardElement(englishBoard[index].english, englishBoard[index].id, 'english', index);
          slotEl.appendChild(card);
        }
      });
      // For Swedish column
      const sweSlots = swedishColumn.querySelectorAll('.slot');
      sweSlots.forEach((slotEl, index) => {
        slotEl.innerHTML = ''; // clear slot content
        if (swedishBoard[index]) {
          const card = createCardElement(swedishBoard[index].swedish, swedishBoard[index].id, 'swedish', index);
          slotEl.appendChild(card);
        }
      });
    }
    
    // Create card element with text, data attributes, and click listener.
    function createCardElement(text, pairId, column, slot) {
      const card = document.createElement('div');
      card.className = 'card';
      card.textContent = text;
      card.dataset.pairId = pairId;
      card.dataset.column = column;
      card.dataset.slot = slot;
      card.addEventListener('click', handleCardClick);
      return card;
    }
    
    // Card click handler
    function handleCardClick(e) {
      const card = e.currentTarget;
      // If card is already selected, deselect it.
      if (card.classList.contains('selected')) {
        card.classList.remove('selected');
        if (selectedCard && selectedCard.element === card) {
          selectedCard = null;
        }
        return;
      }
      
      // If no card is selected, select this one.
      if (!selectedCard) {
        card.classList.add('selected');
        selectedCard = {
          element: card,
          pairId: card.dataset.pairId,
          column: card.dataset.column,
          slot: card.dataset.slot
        };
      } else {
        // If the same column is clicked, change selection.
        if (card.dataset.column === selectedCard.column) {
          selectedCard.element.classList.remove('selected');
          card.classList.add('selected');
          selectedCard = {
            element: card,
            pairId: card.dataset.pairId,
            column: card.dataset.column,
            slot: card.dataset.slot
          };
          return;
        }
        // Now, card is from the opposite column.
        card.classList.add('selected');
        // Check for a match.
        if (card.dataset.pairId === selectedCard.pairId) {
          // Correct match.
          card.classList.remove('selected');
          card.classList.add('correct');
          selectedCard.element.classList.remove('selected');
          selectedCard.element.classList.add('correct');
          
          // Update stats.
          const pid = card.dataset.pairId;
          pairStats[pid].correct++;
          totalCorrectMatches++;
          
          // Remove cards from their fixed slot after a short delay.
          setTimeout(() => {
            removeMatchedPair(pid);
            fillEmptySlotsForPair(pid);
          }, 600);
          
          selectedCard = null;
        } else {
          // Incorrect match.
          // Increment mismatch for both cards.
          const pid1 = selectedCard.pairId;
          const pid2 = card.dataset.pairId;
          pairStats[pid1].mismatches++;
          pairStats[pid2].mismatches++;
          totalMismatches += 2;
          
          // Flash red.
          card.classList.add('wrong');
          selectedCard.element.classList.add('wrong');
          setTimeout(() => {
            card.classList.remove('wrong');
            selectedCard.element.classList.remove('wrong');
            card.classList.remove('selected');
            selectedCard.element.classList.remove('selected');
          }, 600);
          selectedCard = null;
        }
      }
    }
    
    // Remove matched pair from board arrays (based on pair id).
    function removeMatchedPair(pairId) {
      for (let i = 0; i < totalSlots; i++) {
        if (englishBoard[i] && englishBoard[i].id == pairId) {
          englishBoard[i] = null;
        }
        if (swedishBoard[i] && swedishBoard[i].id == pairId) {
          swedishBoard[i] = null;
        }
      }
      renderBoard();
    }
    
    // Fill the empty slots where the matched pair was removed.
    function fillEmptySlotsForPair(pairId) {
      // For each column, check if a slot that previously had the matching pair is now empty; then fill it.
      for (let i = 0; i < totalSlots; i++) {
        if (!englishBoard[i] && remainingPairs.length > 0) {
          englishBoard[i] = remainingPairs.shift();
        }
        if (!swedishBoard[i] && remainingPairs.length > 0) {
          swedishBoard[i] = remainingPairs.shift();
        }
      }
      renderBoard();
    }
    
    // Timer functions.
    function startTimer() {
      updateTimerDisplay();
      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      const m = Math.floor(timeLeft / 60);
      const s = timeLeft % 60;
      timerDisplay.textContent = (m < 10 ? '0' + m : m) + ':' + (s < 10 ? '0' + s : s);
    }
    
    // Back and Finish buttons.
    backButton.addEventListener('click', () => {
      clearInterval(timerInterval);
      // Return to input screen.
      gameSection.classList.add('hidden');
      resultsSection.classList.add('hidden');
      inputSection.classList.remove('hidden');
    });
    
    finishButton.addEventListener('click', () => {
      clearInterval(timerInterval);
      endGame();
    });
    
    /***********************
     * End Game & Results
     ***********************/
    function endGame() {
      // Disable any further clicks on board.
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => {
        card.removeEventListener('click', handleCardClick);
      });
      gameSection.classList.add('hidden');
      displayResults();
      resultsSection.classList.remove('hidden');
    }
    
    // Display results screen: overall totals and detailed table.
    function displayResults() {
      totalsDisplay.innerHTML = `<strong>Total Correct Matches:</strong> ${totalCorrectMatches} &nbsp;&nbsp; <strong>Total Mismatches:</strong> ${totalMismatches}`;
      resultsBody.innerHTML = '';
      vocabularyPairs.forEach(pair => {
        const stats = pairStats[pair.id];
        const row = document.createElement('tr');
        row.innerHTML = `<td>${pair.english}</td>
                         <td>${pair.swedish}</td>
                         <td class="correct-count">${stats.correct}</td>
                         <td class="mismatch-count">${stats.mismatches}</td>`;
        resultsBody.appendChild(row);
      });
    }
    
    // Replay button: restart game with same words and timer.
    replayButton.addEventListener('click', () => {
      // Reset state using originalVocabulary copy.
      vocabularyPairs = JSON.parse(JSON.stringify(originalVocabulary));
      remainingPairs = vocabularyPairs.slice();
      initializePairStats();
      resetGameState();
      timeLeft = selectedTime;
      resultsSection.classList.add('hidden');
      gameSection.classList.remove('hidden');
      renderBoard();
      fillAllEmptySlots();
      startTimer();
    });
    
    // New Words button: return to input screen.
    newWordsButton.addEventListener('click', () => {
      clearInterval(timerInterval);
      resultsSection.classList.add('hidden');
      inputSection.classList.remove('hidden');
    });
  </script>
</body>
</html>
