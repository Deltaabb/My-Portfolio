<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Swedish Vocabulary Matching Game</title>
  <!-- Load Lexend font with several weights -->
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    body {
      font-family: 'Lexend', sans-serif;
      background-color: #f7f7ff; /* soft pastel background */
      margin: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      color: #333;
    }
    h1 {
      font-weight: 700;
      text-align: center;
      margin-bottom: 20px;
    }
    h2 {
      font-weight: 500;
      margin: 10px 0;
    }
    h3 {
      font-weight: 300;
      margin: 10px 0 5px;
    }
    .hidden {
      display: none;
    }
    
    /* Input Section */
    textarea {
      width: 100%;
      height: 200px;
      font-size: 16px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #a3c4f3; /* pastel blue */
      color: white;
      cursor: pointer;
      margin-top: 10px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Game Board */
    #gameBoard {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .column {
      width: 45%;
    }
    /* Each column will have 6 fixed slots */
    .slot {
      height: 50px;
      margin: 5px 0;
      position: relative;
      border: 1px dashed #ddd;
      border-radius: 8px;
      background-color: #fafafa;
    }
    .card {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: opacity 0.5s ease, background-color 0.5s ease;
      font-size: 16px;
      user-select: none;
    }
    /* Default card style */
    .card.default {
      background-color: #fff;
      border: 1px solid #eee;
    }
    /* Selected card */
    .card.selected {
      background-color: #fffacd; /* light pastel yellow */
    }
    /* Correct match */
    .card.correct {
      background-color: #c8e6c9; /* pastel green */
    }
    /* Incorrect match */
    .card.wrong {
      background-color: #ffcdd2; /* pastel red */
    }
    /* Fade-out animation */
    .fade-out {
      opacity: 0;
    }
    
    /* Timer & Results */
    #timer {
      font-size: 24px;
      text-align: center;
      margin-top: 10px;
    }
    #resultsSection {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Swedish Vocabulary Matching Game</h1>

  <!-- Input Section -->
  <div id="inputSection">
    <h2>Enter Your Vocabulary</h2>
    <p>
      Paste your vocabulary data below. Use a tab or comma to separate the English and Swedish words (one pair per line).<br>
      <em>Example:</em><br>
      computer [tab] dator<br>
      dog [tab] hund<br>
      table [tab] bord
    </p>
    <textarea id="vocabInput" placeholder="computer [tab] dator&#10;dog [tab] hund&#10;table [tab] bord"></textarea>
    <br>
    <button id="startButton" disabled>Start Game</button>
  </div>

  <!-- Game Section -->
  <div id="gameSection" class="hidden">
    <div id="timer">02:00</div>
    <div id="gameBoard">
      <div id="englishCards" class="column">
        <h3>English</h3>
        <!-- 6 fixed slots -->
      </div>
      <div id="swedishCards" class="column">
        <h3>Swedish</h3>
        <!-- 6 fixed slots -->
      </div>
    </div>
  </div>

  <!-- Results Section -->
  <div id="resultsSection" class="hidden">
    <h2>Results</h2>
    <p id="scoreDisplay"></p>
    <div id="mismatchReport"></div>
  </div>

  <script>
    /********************
     * Global Variables *
     ********************/
    let vocabularyPairs = [];   // All pairs from user input
    let remainingPairs = [];    // Pairs not yet on board
    let matchedPairsCount = 0;  // Total number of correct matches
    let mismatchCounts = {};    // { pairId: count }
    let selectedCard = null;    // { column, slot, pairId, element }

    const totalSlots = 6; // fixed number of slots per column

    // Board arrays: each index (0 to 5) holds a pair object or null.
    const englishBoard = new Array(totalSlots).fill(null);
    const swedishBoard = new Array(totalSlots).fill(null);

    let timerInterval;
    let timeLeft = 120; // in seconds

    /*******************
     * DOM References  *
     *******************/
    const vocabInput = document.getElementById('vocabInput');
    const startButton = document.getElementById('startButton');
    const inputSection = document.getElementById('inputSection');
    const gameSection = document.getElementById('gameSection');
    const englishCardsDiv = document.getElementById('englishCards');
    const swedishCardsDiv = document.getElementById('swedishCards');
    const timerDisplay = document.getElementById('timer');
    const resultsSection = document.getElementById('resultsSection');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const mismatchReport = document.getElementById('mismatchReport');

    /***********************
     * Initialize Slots    *
     ***********************/
    function initializeBoardSlots() {
      // Clear any existing slots.
      englishCardsDiv.innerHTML = '';
      swedishCardsDiv.innerHTML = '';

      for (let i = 0; i < totalSlots; i++) {
        const engSlot = document.createElement('div');
        engSlot.className = 'slot';
        engSlot.dataset.slot = i;
        englishCardsDiv.appendChild(engSlot);

        const sweSlot = document.createElement('div');
        sweSlot.className = 'slot';
        sweSlot.dataset.slot = i;
        swedishCardsDiv.appendChild(sweSlot);
      }
    }

    /*************************
     * Event Listeners Setup *
     *************************/
    // Enable Start button when there is some input.
    vocabInput.addEventListener('input', () => {
      startButton.disabled = vocabInput.value.trim().length === 0;
    });

    startButton.addEventListener('click', () => {
      parseVocabulary();
      if (vocabularyPairs.length === 0) {
        alert("No valid vocabulary pairs found. Please check your input.");
        return;
      }
      // Reset game state
      remainingPairs = vocabularyPairs.slice();
      matchedPairsCount = 0;
      mismatchCounts = {};
      selectedCard = null;
      timeLeft = 120;

      // Initialize board slots and empty board arrays
      initializeBoardSlots();
      for (let i = 0; i < totalSlots; i++) {
        englishBoard[i] = null;
        swedishBoard[i] = null;
      }
      // Fill the board with as many pairs as possible.
      fillEmptySlots(true);

      // Show game section, hide input and results.
      inputSection.classList.add('hidden');
      resultsSection.classList.add('hidden');
      gameSection.classList.remove('hidden');

      renderBoard();
      startTimer();
    });

    /***********************
     * Parsing Vocabulary  *
     ***********************/
    function parseVocabulary() {
      vocabularyPairs = [];
      const lines = vocabInput.value.trim().split('\n');
      let id = 0;
      lines.forEach(line => {
        // Split on tab or comma.
        let parts = line.split(/\t|,/);
        if (parts.length >= 2) {
          const english = parts[0].trim();
          const swedish = parts[1].trim();
          if (english && swedish) {
            vocabularyPairs.push({ id: id, english: english, swedish: swedish });
            id++;
          }
        }
      });
    }

    /***********************************
     * Timer Functions                 *
     ***********************************/
    function startTimer() {
      timerDisplay.textContent = formatTime(timeLeft);
      timerInterval = setInterval(() => {
        timeLeft--;
        timerDisplay.textContent = formatTime(timeLeft);
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return (m < 10 ? '0' + m : m) + ':' + (s < 10 ? '0' + s : s);
    }

    /********************************************
     * Rendering the Board (Fixed Slots)        *
     ********************************************/
    function renderBoard() {
      // Render English column
      const engSlots = englishCardsDiv.querySelectorAll('.slot');
      engSlots.forEach((slotEl, index) => {
        slotEl.innerHTML = ''; // clear slot
        if (englishBoard[index]) {
          const card = createCardElement(englishBoard[index].english, englishBoard[index].id, 'english', index);
          slotEl.appendChild(card);
        }
      });
      // Render Swedish column
      const sweSlots = swedishCardsDiv.querySelectorAll('.slot');
      sweSlots.forEach((slotEl, index) => {
        slotEl.innerHTML = ''; // clear slot
        if (swedishBoard[index]) {
          const card = createCardElement(swedishBoard[index].swedish, swedishBoard[index].id, 'swedish', index);
          slotEl.appendChild(card);
        }
      });
    }

    function createCardElement(text, pairId, language, slot) {
      const card = document.createElement('div');
      card.className = 'card default';
      card.textContent = text;
      card.dataset.pairId = pairId;
      card.dataset.language = language;
      card.dataset.slot = slot;
      card.addEventListener('click', handleCardClick);
      // Fade in effect:
      card.style.opacity = 0;
      setTimeout(() => { card.style.opacity = 1; }, 100);
      return card;
    }

    /******************************************************
     * Handling Card Clicks and Matching Logic           *
     ******************************************************/
    function handleCardClick(event) {
      const card = event.currentTarget;
      // Ignore clicks on cards already fading out (matched) or marked as correct.
      if (card.classList.contains('fade-out') || card.classList.contains('correct')) return;

      // If no card is selected, mark this card as selected.
      if (!selectedCard) {
        selectedCard = {
          column: card.dataset.language,
          slot: card.dataset.slot,
          pairId: card.dataset.pairId,
          element: card
        };
        card.classList.add('selected');
      } else {
        // If the same card is clicked twice, ignore.
        if (card === selectedCard.element) return;

        // If both selected cards are from the same column, switch selection.
        if (card.dataset.language === selectedCard.column) {
          selectedCard.element.classList.remove('selected');
          selectedCard = {
            column: card.dataset.language,
            slot: card.dataset.slot,
            pairId: card.dataset.pairId,
            element: card
          };
          card.classList.add('selected');
          return;
        }
        // Now, cards are from different columns.
        if (card.dataset.pairId === selectedCard.pairId) {
          // Correct match!
          card.classList.remove('selected');
          card.classList.add('correct');
          selectedCard.element.classList.remove('selected');
          selectedCard.element.classList.add('correct');

          // Remove event listeners by cloning node (to disable further clicks)
          disableCard(selectedCard.element);
          disableCard(card);

          // Remove the matched pair from both boards.
          removeMatchedPair(selectedCard.element.dataset.pairId);

          matchedPairsCount++;

          // After fade-out, fill empty slots.
          // Determine delay: if all slots are empty (i.e. 6 pairs missing), shorten delay.
          const emptyCount = countEmptyPairs();
          const delay = (emptyCount === totalSlots ? 500 : 2000);
          setTimeout(fillEmptySlots, delay);

          selectedCard = null;
        } else {
          // Incorrect match.
          card.classList.add('wrong');
          selectedCard.element.classList.add('wrong');

          // Record mismatch.
          const pid = card.dataset.pairId;
          mismatchCounts[pid] = (mismatchCounts[pid] || 0) + 1;

          // After a short delay, remove the wrong highlight.
          setTimeout(() => {
            card.classList.remove('wrong');
            selectedCard.element.classList.remove('wrong');
          }, 500);
          selectedCard.element.classList.remove('selected');
          selectedCard = null;
        }
      }
    }

    function disableCard(cardElement) {
      const newCard = cardElement.cloneNode(true);
      newCard.removeEventListener('click', handleCardClick);
      cardElement.parentNode.replaceChild(newCard, cardElement);
    }

    function removeMatchedPair(pairId) {
      // Remove from englishBoard
      for (let i = 0; i < totalSlots; i++) {
        if (englishBoard[i] && englishBoard[i].id == pairId) {
          englishBoard[i] = null;
        }
      }
      // Remove from swedishBoard
      for (let i = 0; i < totalSlots; i++) {
        if (swedishBoard[i] && swedishBoard[i].id == pairId) {
          swedishBoard[i] = null;
        }
      }
      // Re-render board for visual update (fade-out effect already played)
      renderBoard();
    }

    /*****************************************************
     * Filling Empty Slots with New Pairs                *
     * If "initial" flag is true, fill all empty slots at  *
     * game start. Otherwise, fill after a correct match.  *
     *****************************************************/
    function fillEmptySlots(initial = false) {
      // Determine how many pairs we can add.
      // We add a pair only if both an empty slot in english and swedish exist.
      let emptyEngIndices = [];
      let emptySweIndices = [];
      for (let i = 0; i < totalSlots; i++) {
        if (!englishBoard[i]) emptyEngIndices.push(i);
        if (!swedishBoard[i]) emptySweIndices.push(i);
      }
      const pairsToFill = Math.min(emptyEngIndices.length, emptySweIndices.length);
      for (let i = 0; i < pairsToFill; i++) {
        if (remainingPairs.length === 0) break;
        const newPair = remainingPairs.shift();
        // Randomly assign newPair to one empty slot in each column.
        const engIndex = emptyEngIndices.splice(Math.floor(Math.random() * emptyEngIndices.length), 1)[0];
        const sweIndex = emptySweIndices.splice(Math.floor(Math.random() * emptySweIndices.length), 1)[0];
        englishBoard[engIndex] = newPair;
        swedishBoard[sweIndex] = newPair;
      }
      renderBoard();
    }

    function countEmptyPairs() {
      // Count how many pairs (by pair id) are missing from both boards.
      let countEng = 0, countSwe = 0;
      for (let i = 0; i < totalSlots; i++) {
        if (!englishBoard[i]) countEng++;
        if (!swedishBoard[i]) countSwe++;
      }
      return Math.min(countEng, countSwe);
    }

    /**************************
     * End Game & Results     *
     **************************/
    function endGame() {
      clearInterval(timerInterval);
      // Disable any remaining card clicks.
      const allCards = document.querySelectorAll('.card');
      allCards.forEach(card => {
        card.removeEventListener('click', handleCardClick);
      });
      gameSection.classList.add('hidden');
      resultsSection.classList.remove('hidden');
      scoreDisplay.textContent = 'Total correct matches: ' + matchedPairsCount;

      // Build mismatch report.
      let reportHTML = '<h3>Words to Review:</h3><ul>';
      vocabularyPairs.forEach(pair => {
        const mismatches = mismatchCounts[pair.id] || 0;
        if (mismatches > 0) {
          reportHTML += `<li>${pair.english} - ${pair.swedish} (mismatches: ${mismatches})</li>`;
        }
      });
      reportHTML += '</ul>';
      mismatchReport.innerHTML = reportHTML;
    }
  </script>
</body>
</html>
